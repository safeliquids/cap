<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cap: ParsedArguments: Storage of Parsed Flags and Arguments</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cap<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Command-line argument parser library for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/d0d/group__parsed__arguments.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ParsedArguments: Storage of Parsed Flags and Arguments</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:d2/d4a/structParsedArguments" id="r_d2/d4a/structParsedArguments"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a></td></tr>
<tr class="memdesc:d2/d4a/structParsedArguments"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all information about command line arguments after successful parsing.  <a href="#d2/d4a/structParsedArguments">More...</a><br /></td></tr>
<tr class="separator:d2/d4a/structParsedArguments"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad3438fd4e3e947ed2aeedb5cb3e8aade" id="r_gad3438fd4e3e947ed2aeedb5cb3e8aade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad3438fd4e3e947ed2aeedb5cb3e8aade">cap_pa_make_empty</a> ()</td></tr>
<tr class="memdesc:gad3438fd4e3e947ed2aeedb5cb3e8aade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object.  <br /></td></tr>
<tr class="separator:gad3438fd4e3e947ed2aeedb5cb3e8aade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8a195a595136eafffbeccd2071ca5a1" id="r_gab8a195a595136eafffbeccd2071ca5a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab8a195a595136eafffbeccd2071ca5a1">cap_pa_destroy</a> (<a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args)</td></tr>
<tr class="memdesc:gab8a195a595136eafffbeccd2071ca5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object.  <br /></td></tr>
<tr class="separator:gab8a195a595136eafffbeccd2071ca5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5a85695a387960d6146ea8e3628a1f" id="r_ga6f5a85695a387960d6146ea8e3628a1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6f5a85695a387960d6146ea8e3628a1f">cap_pa_has_flag</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *flag)</td></tr>
<tr class="memdesc:ga6f5a85695a387960d6146ea8e3628a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a flag is present.  <br /></td></tr>
<tr class="separator:ga6f5a85695a387960d6146ea8e3628a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0bf5bd24546b222ee5da2ed6a66a148" id="r_gac0bf5bd24546b222ee5da2ed6a66a148"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0bf5bd24546b222ee5da2ed6a66a148">cap_pa_flag_count</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *flag)</td></tr>
<tr class="memdesc:gac0bf5bd24546b222ee5da2ed6a66a148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times a flag was given.  <br /></td></tr>
<tr class="separator:gac0bf5bd24546b222ee5da2ed6a66a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d0a96eca51661399cf687e1805b968" id="r_ga52d0a96eca51661399cf687e1805b968"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga52d0a96eca51661399cf687e1805b968">cap_pa_get_flag</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *flag)</td></tr>
<tr class="memdesc:ga52d0a96eca51661399cf687e1805b968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a value stored in the given flag, or <code>NULL</code> if it is absent.  <br /></td></tr>
<tr class="separator:ga52d0a96eca51661399cf687e1805b968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8577861aa4927c776be1197ca54a930b" id="r_ga8577861aa4927c776be1197ca54a930b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8577861aa4927c776be1197ca54a930b">cap_pa_get_flag_i</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *flag, size_t index)</td></tr>
<tr class="memdesc:ga8577861aa4927c776be1197ca54a930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a value stored in the given flag, at the given position.  <br /></td></tr>
<tr class="separator:ga8577861aa4927c776be1197ca54a930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fc2c0f7962693ffa850f48a1d2026d" id="r_ga25fc2c0f7962693ffa850f48a1d2026d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25fc2c0f7962693ffa850f48a1d2026d">cap_pa_add_flag</a> (<a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *flag, <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> value)</td></tr>
<tr class="memdesc:ga25fc2c0f7962693ffa850f48a1d2026d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new value for the given flag.  <br /></td></tr>
<tr class="separator:ga25fc2c0f7962693ffa850f48a1d2026d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeed19955e95f17e45cdd3632a7e01df" id="r_gabeed19955e95f17e45cdd3632a7e01df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabeed19955e95f17e45cdd3632a7e01df">cap_pa_has_positional</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *name)</td></tr>
<tr class="memdesc:gabeed19955e95f17e45cdd3632a7e01df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a positinal argument with this name exists.  <br /></td></tr>
<tr class="separator:gabeed19955e95f17e45cdd3632a7e01df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab41f8692d5aa8f2868919bf9208bffc" id="r_gaab41f8692d5aa8f2868919bf9208bffc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaab41f8692d5aa8f2868919bf9208bffc">cap_pa_positional_count</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *name)</td></tr>
<tr class="memdesc:gaab41f8692d5aa8f2868919bf9208bffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of values stored for a positional.  <br /></td></tr>
<tr class="separator:gaab41f8692d5aa8f2868919bf9208bffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ea3eaca79abc1ed3c8d7d93acd75b2" id="r_ga29ea3eaca79abc1ed3c8d7d93acd75b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga29ea3eaca79abc1ed3c8d7d93acd75b2">cap_pa_get_positional</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *name)</td></tr>
<tr class="memdesc:ga29ea3eaca79abc1ed3c8d7d93acd75b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a positional argument with the given name.  <br /></td></tr>
<tr class="separator:ga29ea3eaca79abc1ed3c8d7d93acd75b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959d6b8557f20097ae04b8b07ebf63a7" id="r_ga959d6b8557f20097ae04b8b07ebf63a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga959d6b8557f20097ae04b8b07ebf63a7">cap_pa_get_positional_i</a> (const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *name, size_t index)</td></tr>
<tr class="memdesc:ga959d6b8557f20097ae04b8b07ebf63a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a positional argument with the given name at the given index.  <br /></td></tr>
<tr class="separator:ga959d6b8557f20097ae04b8b07ebf63a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae728512b9e3a0a5793f501e58ed1d87d" id="r_gae728512b9e3a0a5793f501e58ed1d87d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae728512b9e3a0a5793f501e58ed1d87d">cap_pa_set_positional</a> (<a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *name, const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> value)</td></tr>
<tr class="memdesc:gae728512b9e3a0a5793f501e58ed1d87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value for the given argument.  <br /></td></tr>
<tr class="separator:gae728512b9e3a0a5793f501e58ed1d87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3656e3e1791ffd50d2ae395077e121b" id="r_gac3656e3e1791ffd50d2ae395077e121b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3656e3e1791ffd50d2ae395077e121b">cap_pa_append_positional</a> (<a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *args, const char *name, const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> value)</td></tr>
<tr class="memdesc:gac3656e3e1791ffd50d2ae395077e121b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value for a positional.  <br /></td></tr>
<tr class="separator:gac3656e3e1791ffd50d2ae395077e121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> is the result of parsing arguments given on the command line. An object of this type is usually returned from a configured <code><a class="el" href="../../dd/da8/group__parser.html#d5/db0/structArgumentParser" title="Main object for parsing given command line arguments.">ArgumentParser</a></code> after successful parsing. It should contain information about all configured flags and arguments that were found on the command line. The library offers several functions for creating, deleting, modifying and querying these objects. They are prefixed with <code>cap_pa_</code>.</p>
<p><code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> objects are able to store arguments of two kinds: flags and positional arguments (also called positionals). Each stored argument has a string name and a set of values. The name is most commonly used to query the <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> for the given argument (e.g. if it is present). Values are stored as <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> objects, and pointers to those objects can be returned from a search function call on the <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code>, e.g. <code>cap_pa_get_flag</code>. This way, <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> implements a pair of primitive multi-sets of <code>string --&gt; <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> (one such mapping for flags and one for positionals.)</p>
<p>An empty <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object can be created using <code><a class="el" href="#gad3438fd4e3e947ed2aeedb5cb3e8aade" title="Creates an empty ParsedArguments object.">cap_pa_make_empty()</a></code>. This is normally done at parse-time by the parser so users do not need to create it manually. Objects should be disposed of using <code>cap_pa_destroy</code> when no longer needed. This call invalidates all information obtained from the object, e.g. pointers to <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code>s that were stored as argument values. </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="d2/d4a/structParsedArguments" id="d2/d4a/structParsedArguments"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d2/d4a/structParsedArguments">&#9670;&#160;</a></span>ParsedArguments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ParsedArguments</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure is the main result of parsing command line arguments by a configured parser. All flags and positional arguments are stored with their values as <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> objects. Objects of this type should not be created directly. The function <code>cap_parser_parse</code> should be used instead. Similarly, information about flags and positionals should be obtained using functions such as <code>cap_pa_has_flag</code> or <code>cap_pa_get_positional</code>.</p>
<p>Once created using the <code>cap_parser_parse</code> or <code>cap_pa_make_empty</code> functions, the caller owns this object and should dispose of it using <code>cap_pa_destroy</code> once it is no longer needed. When created by <code>cap_parser_parse</code>, the pointer returned by this function must also be freed. (this is an unfortunate technical limitation.) <code>cap_pa_destroy</code> also deletes all data contained in it, including names of flags, and <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code>s and strings contained in them. If any data obtained from a <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> should be usable after destroying the object, it must be properly copied.</p>
<dl class="section see"><dt>See also</dt><dd>ParsedFlag </dd>
<dd>
ParsedPositional </dd>
<dd>
<a class="el" href="#gad3438fd4e3e947ed2aeedb5cb3e8aade" title="Creates an empty ParsedArguments object.">cap_pa_make_empty</a> </dd>
<dd>
<a class="el" href="#gab8a195a595136eafffbeccd2071ca5a1" title="Destroys a ParsedArguments object.">cap_pa_destroy</a> </dd>
<dd>
<a class="el" href="#ga6f5a85695a387960d6146ea8e3628a1f" title="Checks if a flag is present.">cap_pa_has_flag</a> </dd>
<dd>
<a class="el" href="#gac0bf5bd24546b222ee5da2ed6a66a148" title="Returns the number of times a flag was given.">cap_pa_flag_count</a> </dd>
<dd>
<a class="el" href="#ga52d0a96eca51661399cf687e1805b968" title="Retrieves a value stored in the given flag, or NULL if it is absent.">cap_pa_get_flag</a> </dd>
<dd>
<a class="el" href="#ga8577861aa4927c776be1197ca54a930b" title="Retrieves a value stored in the given flag, at the given position.">cap_pa_get_flag_i</a> </dd>
<dd>
<a class="el" href="#gabeed19955e95f17e45cdd3632a7e01df" title="Checks if a positinal argument with this name exists.">cap_pa_has_positional</a> </dd>
<dd>
<a class="el" href="#ga29ea3eaca79abc1ed3c8d7d93acd75b2" title="Retrieves a positional argument with the given name.">cap_pa_get_positional</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a24c264e2a6b6790aaa98c851aedc84c0" id="r_a24c264e2a6b6790aaa98c851aedc84c0"><td class="memItemLeft" align="right" valign="top"><a id="a24c264e2a6b6790aaa98c851aedc84c0" name="a24c264e2a6b6790aaa98c851aedc84c0"></a>
<a class="el" href="../../de/dd6/group__named__values.html#da/d57/structNamedValuesArray">NamedValuesArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mFlags</b></td></tr>
<tr class="memdesc:a24c264e2a6b6790aaa98c851aedc84c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about individual parsed flags. <br /></td></tr>
<tr class="separator:a24c264e2a6b6790aaa98c851aedc84c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57fcb5649d1ef8c7bcda26415646960" id="r_ae57fcb5649d1ef8c7bcda26415646960"><td class="memItemLeft" align="right" valign="top"><a id="ae57fcb5649d1ef8c7bcda26415646960" name="ae57fcb5649d1ef8c7bcda26415646960"></a>
<a class="el" href="../../de/dd6/group__named__values.html#da/d57/structNamedValuesArray">NamedValuesArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mPositionals</b></td></tr>
<tr class="memdesc:ae57fcb5649d1ef8c7bcda26415646960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about individual positional arguments. <br /></td></tr>
<tr class="separator:ae57fcb5649d1ef8c7bcda26415646960"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga25fc2c0f7962693ffa850f48a1d2026d" name="ga25fc2c0f7962693ffa850f48a1d2026d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fc2c0f7962693ffa850f48a1d2026d">&#9670;&#160;</a></span>cap_pa_add_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_pa_add_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a new value for the given flag to its list of values. <code>args</code> becomes the owner of <code>value</code>. If the flag is not yet present, it is created. In this process, the flag name is copied and <code>args</code> becomes the owner of this copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object to add the flag into. If it is <code>NULL</code>, the function does nothing. </td></tr>
    <tr><td class="paramname">flag</td><td>null-terminated name of the flag in question including any flag prefix characters. If it is <code>NULL</code>, the function does nothing. </td></tr>
    <tr><td class="paramname">value</td><td>value to store for the flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3656e3e1791ffd50d2ae395077e121b" name="gac3656e3e1791ffd50d2ae395077e121b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3656e3e1791ffd50d2ae395077e121b">&#9670;&#160;</a></span>cap_pa_append_positional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_pa_append_positional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new value for a stored positional argument in <code>args</code>. If no such positional exists, it gets also created.</p>
<p>In this process, <code>args</code> becomes the owner of <code>value</code>. Only newly created <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> objects should be passed to this functions. Passing a (shallow) copy of a <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> with dynamic memory (such as the string type) that is already owned by a <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> will lead to double-free faults.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>object to add a value to </td></tr>
    <tr><td class="paramname">name</td><td>null-terminated name of the positional </td></tr>
    <tr><td class="paramname">value</td><td>value to store for this positional </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8a195a595136eafffbeccd2071ca5a1" name="gab8a195a595136eafffbeccd2071ca5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8a195a595136eafffbeccd2071ca5a1">&#9670;&#160;</a></span>cap_pa_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_pa_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> and all data contained in it. All pointers obtained from the given object become invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>object to destroy. If it is <code>NULL</code>, this function does nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac0bf5bd24546b222ee5da2ed6a66a148" name="gac0bf5bd24546b222ee5da2ed6a66a148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0bf5bd24546b222ee5da2ed6a66a148">&#9670;&#160;</a></span>cap_pa_flag_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cap_pa_flag_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>flag</code> is not present in <code>args</code>, returns zero. If a <code>ParsedArgument</code> is only modified using library functions (such as <code>cap_pa_add_flag</code>), it is not possible to create a flag with no values. Therefore, <code>cap_pa_flag_count</code> returning zero is equivalent to <code>cap_pa_has_flag</code> returning false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object to search </td></tr>
    <tr><td class="paramname">flag</td><td>null-terminated string representing the flag name including any leading flag prefix characters (such as '-'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of values stored for the given flag </dd></dl>

</div>
</div>
<a id="ga52d0a96eca51661399cf687e1805b968" name="ga52d0a96eca51661399cf687e1805b968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d0a96eca51661399cf687e1805b968">&#9670;&#160;</a></span>cap_pa_get_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> * cap_pa_get_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the first value stored for the given flag. If the flag is absent, returns <code>NULL</code> instead. If a valid pointer to a <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> object is returned, <code>args</code> remains the owner of that object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object to search </td></tr>
    <tr><td class="paramname">flag</td><td>name of the falg to look up including any flag prefix characters (such as '-'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first value for this flag, or <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ga8577861aa4927c776be1197ca54a930b" name="ga8577861aa4927c776be1197ca54a930b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8577861aa4927c776be1197ca54a930b">&#9670;&#160;</a></span>cap_pa_get_flag_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> * cap_pa_get_flag_i </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the value stored for the given flag located at the given position. If there are too few values, returns <code>NULL</code> instead. If a valid pointer to a <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> object is returned, <code>args</code> remains the owner of that object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object to search </td></tr>
    <tr><td class="paramname">flag</td><td>name of the falg to look up including any flag prefix characters (such as '-'). </td></tr>
    <tr><td class="paramname">index</td><td>position of the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value for this flag indicated by <code>index</code>, or <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ga29ea3eaca79abc1ed3c8d7d93acd75b2" name="ga29ea3eaca79abc1ed3c8d7d93acd75b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29ea3eaca79abc1ed3c8d7d93acd75b2">&#9670;&#160;</a></span>cap_pa_get_positional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> * cap_pa_get_positional </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if <code>args</code> contains a positional argument named <code>name</code> and, if it is present, returns a pointer to its value. Returns <code>NULL</code> if no such positional argument exists or if <code>args</code> or <code>name</code> are <code>NULL</code>. Do note that, if a valid pointer to a <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> object is returned, <code>args</code> remains the owner of that object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>object to search </td></tr>
    <tr><td class="paramname">name</td><td>null-terminated name of the positional argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the argument's value, or <code>NULL</code> if it is not found. </dd></dl>

</div>
</div>
<a id="ga959d6b8557f20097ae04b8b07ebf63a7" name="ga959d6b8557f20097ae04b8b07ebf63a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga959d6b8557f20097ae04b8b07ebf63a7">&#9670;&#160;</a></span>cap_pa_get_positional_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a> * cap_pa_get_positional_i </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if <code>args</code> contains a positional argument named <code>name</code>. If it is present and there are at least <code>index + 1</code> values stored for it returns the value at position <code>index</code> (starting at zero). Returns <code>NULL</code> if that argument does not exist or there are not enough values. Also returns <code>NULL</code> if <code>args</code> or <code>name</code> are <code>NULL</code>. Do note that, if a valid pointer to a <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> object is returned, <code>args</code> remains the owner of that object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>object to search </td></tr>
    <tr><td class="paramname">name</td><td>null-terminated name of the positional argument </td></tr>
    <tr><td class="paramname">index</td><td>index of the requested value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the argument's value at <code>index</code>, or <code>NULL</code> if it is not found. </dd></dl>

</div>
</div>
<a id="ga6f5a85695a387960d6146ea8e3628a1f" name="ga6f5a85695a387960d6146ea8e3628a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f5a85695a387960d6146ea8e3628a1f">&#9670;&#160;</a></span>cap_pa_has_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cap_pa_has_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object to search </td></tr>
    <tr><td class="paramname">flag</td><td>null-terminated string name of the flag, including any leading flag prefix characters (such as '-'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>flag</code> is present </dd></dl>

</div>
</div>
<a id="gabeed19955e95f17e45cdd3632a7e01df" name="gabeed19955e95f17e45cdd3632a7e01df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeed19955e95f17e45cdd3632a7e01df">&#9670;&#160;</a></span>cap_pa_has_positional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cap_pa_has_positional </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if <code>args</code> contains a positional argument with the name <code>name</code>. If <code>args</code> or <code>name</code> are <code>NULL</code>, always returns <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>object to search </td></tr>
    <tr><td class="paramname">name</td><td>null-terminated argument name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a positional argument <code>name</code> exists </dd></dl>

</div>
</div>
<a id="gad3438fd4e3e947ed2aeedb5cb3e8aade" name="gad3438fd4e3e947ed2aeedb5cb3e8aade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3438fd4e3e947ed2aeedb5cb3e8aade">&#9670;&#160;</a></span>cap_pa_make_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> * cap_pa_make_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> containing no flags or positionals. </p>

</div>
</div>
<a id="gaab41f8692d5aa8f2868919bf9208bffc" name="gaab41f8692d5aa8f2868919bf9208bffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab41f8692d5aa8f2868919bf9208bffc">&#9670;&#160;</a></span>cap_pa_positional_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cap_pa_positional_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if <code>args</code> contains a positional argument with the name <code>name</code>. If <code>args</code> or <code>name</code> are <code>NULL</code>, or if <code>name</code> is not contained in <code>args</code>, returns zero. Else returns the number of values stored for <code>name</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>object to search </td></tr>
    <tr><td class="paramname">name</td><td>null-terminated name of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of values stored for <code>name</code> </dd></dl>

</div>
</div>
<a id="gae728512b9e3a0a5793f501e58ed1d87d" name="gae728512b9e3a0a5793f501e58ed1d87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae728512b9e3a0a5793f501e58ed1d87d">&#9670;&#160;</a></span>cap_pa_set_positional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_pa_set_positional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d2/d4a/structParsedArguments">ParsedArguments</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion">TypedUnion</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a positional argument with the given name and replaces its value with <code>value</code>. In this process, <code>args</code> becomes the owner of <code>value</code>. Only newly created <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> objects should be passed to this functions. Passing a (shallow) copy of a <code><a class="el" href="../../d5/dba/group__typed__union.html#da/dce/structTypedUnion" title="Elementary storage of values whose type is not known at compile-time.">TypedUnion</a></code> with dynamic memory (such as the string type) that is already owned by a <code><a class="el" href="#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> will lead to double-free faults.</p>
<p>If no positional argument with the name <code>name</code> exists in <code>args</code>, it is created. A copy of <code>name</code> is made when creating the argument in <code>args</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>object to set the new value in </td></tr>
    <tr><td class="paramname">name</td><td>null-terminated name of the positional argument to set a new value for </td></tr>
    <tr><td class="paramname">value</td><td>the new value. <code>args</code> becomes the owner of this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
