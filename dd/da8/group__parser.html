<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cap: Argument Parser, its Configuration, and Usage</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cap<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Command-line argument parser library for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/da8/group__parser.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Argument Parser, its Configuration, and Usage</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:d5/db0/structArgumentParser" id="r_d5/db0/structArgumentParser"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a></td></tr>
<tr class="memdesc:d5/db0/structArgumentParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main object for parsing given command line arguments.  <a href="#d5/db0/structArgumentParser">More...</a><br /></td></tr>
<tr class="separator:d5/db0/structArgumentParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d05/structParsingResult" id="r_db/d05/structParsingResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#db/d05/structParsingResult">ParsingResult</a></td></tr>
<tr class="memdesc:db/d05/structParsingResult"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of argument parsing.  <a href="#db/d05/structParsingResult">More...</a><br /></td></tr>
<tr class="separator:db/d05/structParsingResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga58a8c0ce4aa40191214d1fa2c009adb3" id="r_ga58a8c0ce4aa40191214d1fa2c009adb3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58a8c0ce4aa40191214d1fa2c009adb3">ParsingError</a> { <br />
&#160;&#160;<a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3a6f001fa527c8eaf63b34577be447dad8">PER_NO_ERROR</a>
, <a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3a796384e69d34756fa38cca83fa8a7092">PER_HELP</a>
, <a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3af9a637955ea2ab0009e71b0662e99efa">PER_NOT_ENOUGH_POSITIONALS</a>
, <a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3a7ca650aa9cc7031a96b216993fa837d7">PER_TOO_MANY_POSITIONALS</a>
, <br />
&#160;&#160;<a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3a50abee75e07b8446b46f1d2010775408">PER_CANNOT_PARSE_POSITIONAL</a>
, <a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3ae40c71ef696f53131aaf88b97d98a826">PER_UNKNOWN_FLAG</a>
, <a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3a00280011690dddf0a70a1c9a579f7ae8">PER_MISSING_FLAG_VALUE</a>
, <a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3a9a6349c74f2cc86c6fe1f123b017c81b">PER_CANNOT_PARSE_FLAG</a>
, <br />
&#160;&#160;<a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3ac4fb5d8eece8a5211e776eb564a773c2">PER_NOT_ENOUGH_FLAGS</a>
, <a class="el" href="#gga58a8c0ce4aa40191214d1fa2c009adb3a29753f054e3afe4c93abe4bfd6153835">PER_TOO_MANY_FLAGS</a>
<br />
 }</td></tr>
<tr class="memdesc:ga58a8c0ce4aa40191214d1fa2c009adb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a parse-time error.  <a href="#ga58a8c0ce4aa40191214d1fa2c009adb3">More...</a><br /></td></tr>
<tr class="separator:ga58a8c0ce4aa40191214d1fa2c009adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaef82bc92775d7902066744534c7f3f86" id="r_gaef82bc92775d7902066744534c7f3f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaef82bc92775d7902066744534c7f3f86">cap_parser_set_help_flag</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *name, const char *description)</td></tr>
<tr class="memdesc:gaef82bc92775d7902066744534c7f3f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag for displaying help.  <br /></td></tr>
<tr class="separator:gaef82bc92775d7902066744534c7f3f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30894b0158cf392fc1489b22e52b1223" id="r_ga30894b0158cf392fc1489b22e52b1223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30894b0158cf392fc1489b22e52b1223">cap_parser_set_flag_separator</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *separator, const char *description)</td></tr>
<tr class="memdesc:ga30894b0158cf392fc1489b22e52b1223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag separator.  <br /></td></tr>
<tr class="separator:ga30894b0158cf392fc1489b22e52b1223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6dcbda38abac6c517adffa18fe2bef9" id="r_gae6dcbda38abac6c517adffa18fe2bef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6dcbda38abac6c517adffa18fe2bef9">cap_parser_enable_help</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, bool enable)</td></tr>
<tr class="memdesc:gae6dcbda38abac6c517adffa18fe2bef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disable displaying help.  <br /></td></tr>
<tr class="separator:gae6dcbda38abac6c517adffa18fe2bef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec3ea97a7a66869e1e7e2191323e2633" id="r_gaec3ea97a7a66869e1e7e2191323e2633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaec3ea97a7a66869e1e7e2191323e2633">cap_parser_enable_usage</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, bool enable)</td></tr>
<tr class="memdesc:gaec3ea97a7a66869e1e7e2191323e2633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disable displaying usage.  <br /></td></tr>
<tr class="separator:gaec3ea97a7a66869e1e7e2191323e2633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13174dda05075576f8e1fffb4356bb49" id="r_ga13174dda05075576f8e1fffb4356bb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga13174dda05075576f8e1fffb4356bb49">cap_parser_make_empty</a> ()</td></tr>
<tr class="memdesc:ga13174dda05075576f8e1fffb4356bb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty parser.  <br /></td></tr>
<tr class="separator:ga13174dda05075576f8e1fffb4356bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc09eb179b1199958b0aed13020ec884" id="r_gabc09eb179b1199958b0aed13020ec884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc09eb179b1199958b0aed13020ec884">cap_parser_make_default</a> ()</td></tr>
<tr class="memdesc:gabc09eb179b1199958b0aed13020ec884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new default parser.  <br /></td></tr>
<tr class="separator:gabc09eb179b1199958b0aed13020ec884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed98696f672b0b407dae5719221fc748" id="r_gaed98696f672b0b407dae5719221fc748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed98696f672b0b407dae5719221fc748">cap_parser_destroy</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser)</td></tr>
<tr class="memdesc:gaed98696f672b0b407dae5719221fc748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an <code><a class="el" href="#d5/db0/structArgumentParser" title="Main object for parsing given command line arguments.">ArgumentParser</a></code> object.  <br /></td></tr>
<tr class="separator:gaed98696f672b0b407dae5719221fc748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9d15cfb79e9c90649edf0d09d52c1d1" id="r_gad9d15cfb79e9c90649edf0d09d52c1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9d15cfb79e9c90649edf0d09d52c1d1">cap_parser_set_flag_prefix</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *prefix_chars)</td></tr>
<tr class="memdesc:gad9d15cfb79e9c90649edf0d09d52c1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets characters to be considered flag-prefix characters.  <br /></td></tr>
<tr class="separator:gad9d15cfb79e9c90649edf0d09d52c1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08651dbf827fd7867224a35dd2a4b363" id="r_ga08651dbf827fd7867224a35dd2a4b363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga08651dbf827fd7867224a35dd2a4b363">cap_parser_set_program_name</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *name)</td></tr>
<tr class="memdesc:ga08651dbf827fd7867224a35dd2a4b363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the program.  <br /></td></tr>
<tr class="separator:ga08651dbf827fd7867224a35dd2a4b363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05828f893b3919311e60582aff8fd10" id="r_gaf05828f893b3919311e60582aff8fd10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf05828f893b3919311e60582aff8fd10">cap_parser_set_description</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *description)</td></tr>
<tr class="memdesc:gaf05828f893b3919311e60582aff8fd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the program's description.  <br /></td></tr>
<tr class="separator:gaf05828f893b3919311e60582aff8fd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0241869c382f2c422f57649e45119ed3" id="r_ga0241869c382f2c422f57649e45119ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0241869c382f2c422f57649e45119ed3">cap_parser_set_epilogue</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *epilogue)</td></tr>
<tr class="memdesc:ga0241869c382f2c422f57649e45119ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the epilogue of the program's help.  <br /></td></tr>
<tr class="separator:ga0241869c382f2c422f57649e45119ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c078c2e4cf4b884e5c60b1b0541383" id="r_ga50c078c2e4cf4b884e5c60b1b0541383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50c078c2e4cf4b884e5c60b1b0541383">cap_parser_set_custom_help</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *help)</td></tr>
<tr class="memdesc:ga50c078c2e4cf4b884e5c60b1b0541383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom help message.  <br /></td></tr>
<tr class="separator:ga50c078c2e4cf4b884e5c60b1b0541383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d359e80759d76dcdb8546ea1e27341" id="r_gab8d359e80759d76dcdb8546ea1e27341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab8d359e80759d76dcdb8546ea1e27341">cap_parser_set_custom_usage</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *usage)</td></tr>
<tr class="memdesc:gab8d359e80759d76dcdb8546ea1e27341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom usage string.  <br /></td></tr>
<tr class="separator:gab8d359e80759d76dcdb8546ea1e27341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c06909958e3744b377ac6e484b16e0" id="r_gae2c06909958e3744b377ac6e484b16e0"><td class="memItemLeft" align="right" valign="top">AddFlagError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2c06909958e3744b377ac6e484b16e0">cap_parser_add_flag_noexit</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *flag, <a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, int min_count, int max_count, const char *metavar, const char *description)</td></tr>
<tr class="memdesc:gae2c06909958e3744b377ac6e484b16e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a flag in an argument parser.  <br /></td></tr>
<tr class="separator:gae2c06909958e3744b377ac6e484b16e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984d16e375dd8704a3682e0bcecddfae" id="r_ga984d16e375dd8704a3682e0bcecddfae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga984d16e375dd8704a3682e0bcecddfae">cap_parser_add_flag</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *flag, <a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, int min_count, int max_count, const char *meta_var, const char *description)</td></tr>
<tr class="memdesc:ga984d16e375dd8704a3682e0bcecddfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a flag in an argument parser.  <br /></td></tr>
<tr class="separator:ga984d16e375dd8704a3682e0bcecddfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf0403567eae7009db5175f7fd29455" id="r_gaadf0403567eae7009db5175f7fd29455"><td class="memItemLeft" align="right" valign="top">AddFlagAliasError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaadf0403567eae7009db5175f7fd29455">cap_parser_add_flag_alias_noexit</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *name, const char *alias)</td></tr>
<tr class="memdesc:gaadf0403567eae7009db5175f7fd29455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an alias for an existing flag.  <br /></td></tr>
<tr class="separator:gaadf0403567eae7009db5175f7fd29455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6eae74cf8edcdfa5897c7ead149ce7" id="r_ga0d6eae74cf8edcdfa5897c7ead149ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0d6eae74cf8edcdfa5897c7ead149ce7">cap_parser_add_flag_alias</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *name, const char *alias)</td></tr>
<tr class="memdesc:ga0d6eae74cf8edcdfa5897c7ead149ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an alias for an existing flag.  <br /></td></tr>
<tr class="separator:ga0d6eae74cf8edcdfa5897c7ead149ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c1516b2e3b6bf3a8d2ce1d4257097e" id="r_gae9c1516b2e3b6bf3a8d2ce1d4257097e"><td class="memItemLeft" align="right" valign="top">AddPositionalError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9c1516b2e3b6bf3a8d2ce1d4257097e">cap_parser_add_positional_noexit</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *name, <a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, bool required, bool variadic, const char *metavar, const char *description)</td></tr>
<tr class="memdesc:gae9c1516b2e3b6bf3a8d2ce1d4257097e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a new positional argument.  <br /></td></tr>
<tr class="separator:gae9c1516b2e3b6bf3a8d2ce1d4257097e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae510ae93fe4d5048f8566a2801abd156" id="r_gae510ae93fe4d5048f8566a2801abd156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae510ae93fe4d5048f8566a2801abd156">cap_parser_add_positional</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *name, <a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> type, bool required, bool variadic, const char *metavar, const char *description)</td></tr>
<tr class="memdesc:gae510ae93fe4d5048f8566a2801abd156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a new positional argument.  <br /></td></tr>
<tr class="separator:gae510ae93fe4d5048f8566a2801abd156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46213ece4e095432953aadf16f396ea1" id="r_ga46213ece4e095432953aadf16f396ea1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga46213ece4e095432953aadf16f396ea1">cap_parser_get_program_name</a> (const <a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, const char *argv0)</td></tr>
<tr class="memdesc:ga46213ece4e095432953aadf16f396ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the program name for this parser.  <br /></td></tr>
<tr class="separator:ga46213ece4e095432953aadf16f396ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9947372999a822fffdb60534d2676382" id="r_ga9947372999a822fffdb60534d2676382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9947372999a822fffdb60534d2676382">cap_parser_print_usage</a> (const <a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, FILE *file, const char *argv0)</td></tr>
<tr class="memdesc:ga9947372999a822fffdb60534d2676382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a usage string.  <br /></td></tr>
<tr class="separator:ga9947372999a822fffdb60534d2676382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b39c8bb05b3084f5e373a6e2c7d4b3e" id="r_ga2b39c8bb05b3084f5e373a6e2c7d4b3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b39c8bb05b3084f5e373a6e2c7d4b3e">cap_parser_print_help</a> (const <a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, FILE *file)</td></tr>
<tr class="memdesc:ga2b39c8bb05b3084f5e373a6e2c7d4b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a help message.  <br /></td></tr>
<tr class="separator:ga2b39c8bb05b3084f5e373a6e2c7d4b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd6d249ea681d433a52ca47298383ec" id="r_gacdd6d249ea681d433a52ca47298383ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#db/d05/structParsingResult">ParsingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacdd6d249ea681d433a52ca47298383ec">cap_parser_parse_noexit</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, int argc, const char **argv)</td></tr>
<tr class="memdesc:gacdd6d249ea681d433a52ca47298383ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse comand line arguments without exiting when an error is encountered.  <br /></td></tr>
<tr class="separator:gacdd6d249ea681d433a52ca47298383ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e5587843006db2bd43c2f2ad6c08b3" id="r_ga67e5587843006db2bd43c2f2ad6c08b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments">ParsedArguments</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga67e5587843006db2bd43c2f2ad6c08b3">cap_parser_parse</a> (<a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *parser, int argc, const char **argv)</td></tr>
<tr class="memdesc:ga67e5587843006db2bd43c2f2ad6c08b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses command line arguments.  <br /></td></tr>
<tr class="separator:ga67e5587843006db2bd43c2f2ad6c08b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>An <code><a class="el" href="#d5/db0/structArgumentParser" title="Main object for parsing given command line arguments.">ArgumentParser</a></code> is the main interface of the library. It is an object that can be configured with flags, positionals, program description and other information. A configured object is then used to parse arguments from the command line (the <code>argc</code> array). On successful parsing, a <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object is created which stores all parsed arguments. Functons related to the <code><a class="el" href="#d5/db0/structArgumentParser" title="Main object for parsing given command line arguments.">ArgumentParser</a></code> type are prefixed with <code>cap_parser_</code>.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Times</h2>
<p>There are two important events related to an <code><a class="el" href="#d5/db0/structArgumentParser" title="Main object for parsing given command line arguments.">ArgumentParser</a></code> object: configuration-time and parse-time. Configuration-time takes place between the creation of a parser and its use for parsing command line arguments. During configuration-time, many properties of a parser can be added or changed. These configurations are explained in more depth in the section Configuration. If anything goes wrong with the parser (e.g. the user attempts to create an invalid configuration), a configuration-time error occurs, which usually forcefully exits the program.</p>
<p>Parse-time takes place when command line arguments (i.e. words stored in <code>argv</code>) are given to a parser in order to create an output. No changes happen to the parser object at this time. If any problems arise, such as not enough arguments or not being able to parse a word, a parse-time error occurs. This also usually exits the program.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Creation</h2>
<p>There are two factory functions for parsers: <code>cap_parser_make_empty</code> and <code>cap_parser_make_default</code>. The <code>default</code> function creates a parser with some useful initial configuration, e.g. a help flag. Objects returned from these functions are otherwise functionally identical. When configured, an <code><a class="el" href="#d5/db0/structArgumentParser" title="Main object for parsing given command line arguments.">ArgumentParser</a></code> stores dynamically allocated data, so it needs to be properly disposed of when no longer needed. That is done using the <code>cap_parser_destroy</code> function. <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> objects created by this parser are independent of it and can be used even after the parser has been destroyed.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Configuration</h2>
<p>The two main ways of configuring a parser are creating flags and positional arguments (or "positionals"). Other configurations are</p><ul>
<li>flag prefix characters,</li>
<li>special flags,</li>
<li>custom program name,</li>
<li>program description,</li>
<li>automatic or manual creation of help and usage messages, and</li>
<li>enabling or disabling display of help and/or usage.</li>
</ul>
<p>Do keep in mind that, in this document, "configuring a parser" is a general expression used for any of the above listed changes to a parser. "Defining" a flag is the same as "configuring" it, "configuring a flag in the parser", or "configuring the parser with a flag". Similar terminology is used for other configurations, such as positionals, descriptions, or a custom usage message.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Positional Arguments</h3>
<p>Positional arguments are inputs to a program given as words on the command line. Their meaning and interpretation are decided based on their order on the command line, hence being positional. In this way, positionals are very similar to arguments given to a function in a programming language such as C. This order is decided by the programmer at configuration-time: positinoals are expected on the command line in the same order as they were defined in the program. Positionals are configured in a parser using the <code>cap_parser_add_positional</code> function.</p>
<p>Positionals are defined using a string name, a data type, their required-ness, and variadicity. The name is used to find its values in a created <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code>. The data type dictates how to interpret the word on the command line (i.e. in <code>argv</code>) and is one of the primitive types described in <a class="el" href="../../d5/dba/group__typed__union.html">Data Types and Typed Unions</a> with exception of the <code>DT_PRESENCE</code> type (see later). Required-ness decides if the argument may be missing on the command line - if it is required, it may not be missing. Variadicity decides if the positional is allowed to accept multiple values. (Normally, all positionals take exactly one value if they are not missing.)</p>
<p>Required-ness relates to an important concept: at parse-time, once the parser decides to skip a positional that is is configured as optional, it also skips parsing all other positionals that were configured after it. This means that after configuring one optional positional argument, all following positionals must be configured as optional as well. In other words, a required positional may not be configured after an optional one. Attempting that creates a configuration-time error.</p>
<p>Variadicity relates to another concept: at parse-time, once the parser decides that the positional to parse next is variadic, all words that would be positional values (i.e. they are not flags, see later) are parsed as values for this positional. This means that, at configuration time, no more positionals may be configured after a variadic one. Attempting that creates a configuration-time error. NB that, a variadic argument can also be required.</p>
<p>Positionals can also have two optional (but useful) properties: a description and a meta-var. They are both used in automatically created help messages. The former is a short text explaining the meaning of the argument. The latter is an intuitive name that represents the value of the argument in the usage string.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Flags</h3>
<p>Flags differ from positionals in that they are not identified by their position on the command line. Instead, they are identified by a string literal (the flag's name, or sometimes informally called "the flag") found on the command line, and are sometimes followed by a single value. (In that case this value is not considered a positional value, of course.) This means that, flags can appear in any order and can even mix inbetween positionals, without disrupting their (very important) order.</p>
<p>A flag is configured in a parser using the <code>cap_parser_add_flag</code> function. That is done with its name, data type, minimum count and maximum count. The name is a string literal which must begin with a flag prefix character. By default that is '-' (dash), but can be changed, see later. The name serves two purposes:</p><ol type="1">
<li>it identifies the flag in a <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object, and</li>
<li>it locates the flag and its value on the command line.</li>
</ol>
<p>The data type identifies how the flag's value should be parsed and stored. Available types are the ones defined in <a class="el" href="../../d5/dba/group__typed__union.html">Data Types and Typed Unions</a> . Contrary to positionals, the <code>DT_PRESENCE</code> type is allowed here. It is used to define flags that are not followed by a value. The flag's presence or absence <em>is</em> the information.</p>
<p>The minimum and maximum count define how many times the flag can be present on the command line. For example, setting the minimum to zero configures a flag that may be omitted on the command line. Conversely, if a flag is configured with a minimum count greater than zero, and it is not found at parse-time, a parse-time error occurs. Similarly, a parse-time error occurs if a flag is found more times than is its maximum count. The maximum count can be set to <code>-1</code> to allow the flag to be parsed up to any number of times.</p>
<p>Flags also have two optional properties: a description and a meta-var. Their meaning is exactly the same as for positionals. The only difference is that, configuring a meta-var for a flag of the "presence type" has no effect; those flags take no values, so they are displayed with no meta-variable in automatically generated help messages.</p>
<p>It is also possible to create aliases for configured flags, e.g. to allow long and short spelling of the flag. That is done using the <code>cap_parser_add_flag_alias</code> function.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Flag Prefix Characters</h3>
<p>By default '-' (dash), these characters identify a word as a flag name. At parse-time, the parser treates all words it encounters as flags if they begin with one of the flag prefix characters. That happens even if the word does not match any configured flag names or aliases. In that case, a parse-time error is created (with an error message mentioning an "unknown flag"). There is a way to allow words that begin with a flag prefix character to be parsed as positional values (e.g. negative numbers). It is called positional-only mode and is described later, in the Special Flags section.</p>
<p>It is possible to change the set of flag prefix characters using the <code>parser_set_flag_prefix</code> function. It is not allowed to do that after any flags have been configured, however, so calling the function will create a configuration-time error. This unfortunately includes the default help flag ('-h') which is present in the default parser.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Special Flags</h3>
<p>Now is a good time to mention some special flags. Namely, that is the automatic help flag and the flag separator. At configuratino-time, these behave largely the same as regular flags, but they are handled differently at parse-time. The main configuration-time difference is that, to define or change them, the user must call <code>cap_parser_set_help_flag</code> and <code>cap_parser_set_flag_separator</code> respectively, instead of the usual <code>cap_parser_add_flag</code> function.</p>
<p>The automatic help flag ('-h' by default) is used to invoke help text at parse-time. This can be either a automatically generated help message (the default), or a custom help text configured by the user. The flag must indeed be treated in this special way, so that a help message can be printed even if the command line is "invalid". As mentioned above, the help flag is configured using the <code>cap_parser_set_help_flag</code> function. Compared to <code>cap_parser_add_flag</code>, this allows the user to replace the help flag with a new configuration, (for instance if the default is not desirable). Aliases can be configured exactly the same as for regular flags.</p>
<p>The flag separator ('&ndash;' by default) is a "command" that instructs the parser to enter positional-only mode at parse-time. In this mode, all words that have not yet been consumed are treated as positional arguments, even if they begin with a flag prefix character (see above section Flag Prefix Characters). This allows for positional argument values that the parser would otherwise consider as "unknown flag", such as negative numbers. Again, it is necessary to treat the flag separator in a special way, because it influences parser logic at parse-time. The function <code>cap_parser_set_flag_separator</code> is used to configure this special flag instead of the usual <code>cap_parser_add_flag</code>. This, similarly to the help flag, allows the user to re-configure or disable it. Creating aliases is also allowed.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Custom Program Name and Desctiption</h3>
<p>The parser sometimes needs to display the program name, e.g. when a value cannot be parsed as the desired type and an error message is in order. By default, the parser extracts the program name from the first string in <code>argv</code>. However, it is possible to override this and configure a program name explicitly. This can be done using the <code>cap_parser_set_program_name</code> function.</p>
<p>Similarly, a description of the program can be configured. This is a text displayed at the top of an automatically generated help message (see later). It is also possible to configure an epilogue, a text do be displayed at the very end of the help message. These texts are empty by default and can be configured using <code>cap_parser_set_description</code> and <code>cap_parser_set_epilogue</code> functions respectively.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Automatic and Manual Help Texts</h3>
<p>When encountering a parse-time error, the parser is able to print a help message before exiting the program. By default, this message is automatically generated on-demand based on configured flags and positionals, but it can be explicitly changed to anything the user wants. That is done using <code>cap_parser_set_custom_help</code>. The automatic help looks similar to this. </p><div class="fragment"><div class="line">usage:</div>
<div class="line">    prog.exe [ -f FORMAT ] INPUT_FILE [ OUTPUT_FILE ]</div>
<div class="line"> </div>
<div class="line">Prog is a simple tool <span class="keywordflow">for</span> doing useful things.</div>
<div class="line"> </div>
<div class="line">Available Flags:</div>
<div class="line">-f FORMAT</div>
<div class="line">    A c-style format <span class="keywordtype">string</span></div>
<div class="line"> </div>
<div class="line">Positional Arguments:</div>
<div class="line">INPUT_FILE</div>
<div class="line">    Read input from <span class="keyword">this</span> file</div>
<div class="line">OUTPUT_FILE</div>
<div class="line">    Write output to <span class="keyword">this</span> file. If missing, print to standard output.</div>
</div><!-- fragment --><p>TODO</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Parsing</h2>
<p>TODO </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="d5/db0/structArgumentParser" id="d5/db0/structArgumentParser"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d5/db0/structArgumentParser">&#9670;&#160;</a></span>ArgumentParser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ArgumentParser</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This object contains all information about configured flags and positional arguments, including their types, names, and (for flags) how many times they may be present. Once configured, this object is passed to the <code>cap_parser_parse</code> function to parse given command line arguments. That produces a <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object, or exits the program if an error occurs, e.g. if a given argument cannot be converted to the required type. It is safe to reuse a configured parser for multiple arrays of arguments.</p>
<p>Objects of this type should be created using the factory function <code>cap_parser_make_empty</code>. Configuration is done using functions such as <code>cap_parser_add_flag</code> and <code>cap_parser_add_positional</code>. If an error occurs when configuring the parser (e.g. the same flag name is used in multiple calls to <code>cap_parser_add_flag</code>) the program exits with an error message.</p>
<p>This object can be disposed of using <code>cap_parser_destroy</code> when it is no longer needed. Any produced <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> objects are not affected by this and can be used even after the parser is destroyed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga13174dda05075576f8e1fffb4356bb49" title="Creates a new empty parser.">cap_parser_make_empty</a> </dd>
<dd>
<a class="el" href="#gaed98696f672b0b407dae5719221fc748" title="Destroys an ArgumentParser object.">cap_parser_destroy</a> </dd>
<dd>
<a class="el" href="#ga984d16e375dd8704a3682e0bcecddfae" title="Registers a flag in an argument parser.">cap_parser_add_flag</a> </dd>
<dd>
<a class="el" href="#gae510ae93fe4d5048f8566a2801abd156" title="Configures a new positional argument.">cap_parser_add_positional</a> </dd>
<dd>
<a class="el" href="#ga67e5587843006db2bd43c2f2ad6c08b3" title="Parses command line arguments.">cap_parser_parse</a> </dd></dl>
</div>
</div>
</div>
<a name="db/d05/structParsingResult" id="db/d05/structParsingResult"></a>
<h2 class="memtitle"><span class="permalink"><a href="#db/d05/structParsingResult">&#9670;&#160;</a></span>ParsingResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ParsingResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents the result of processing command line arguments using a configured parser. This object is returned by the <code>cap_parser_parse_noexit</code> function, which does not exit the running program when an error is encountered. The success, result, and error message for that parsing operation are stored in this object.</p>
<dl class="section note"><dt>Note</dt><dd><code>cap_parser_parse_noexit</code> and by extension <code><a class="el" href="#db/d05/structParsingResult" title="Result of argument parsing.">ParsingResult</a></code> exist mainly for unit testing purposes. Users should primarily use <code>cap_parser_parse</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cap_parser_parser_noexit </dd>
<dd>
<a class="el" href="#ga67e5587843006db2bd43c2f2ad6c08b3" title="Parses command line arguments.">cap_parser_parse</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a2f215e675896cba2c128f4c656313675" id="r_a2f215e675896cba2c128f4c656313675"><td class="memItemLeft" align="right" valign="top"><a id="a2f215e675896cba2c128f4c656313675" name="a2f215e675896cba2c128f4c656313675"></a>
<a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments">ParsedArguments</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mArguments</b></td></tr>
<tr class="memdesc:a2f215e675896cba2c128f4c656313675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of argument parsing, or <code>NULL</code> if an error occured. <br /></td></tr>
<tr class="separator:a2f215e675896cba2c128f4c656313675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c6f8ff95fa3c73d1123fd6df91f6cf" id="r_a48c6f8ff95fa3c73d1123fd6df91f6cf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48c6f8ff95fa3c73d1123fd6df91f6cf">mFirstErrorWord</a></td></tr>
<tr class="memdesc:a48c6f8ff95fa3c73d1123fd6df91f6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">first word to be inserted into an error message.  <br /></td></tr>
<tr class="separator:a48c6f8ff95fa3c73d1123fd6df91f6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60ebef2cf17c39ca0daaf50604ab93c" id="r_ab60ebef2cf17c39ca0daaf50604ab93c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab60ebef2cf17c39ca0daaf50604ab93c">mSecondErrorWord</a></td></tr>
<tr class="memdesc:ab60ebef2cf17c39ca0daaf50604ab93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">second word to be inserted into an error message.  <br /></td></tr>
<tr class="separator:ab60ebef2cf17c39ca0daaf50604ab93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8ac8963ffdeba7523579d2ec98b22c" id="r_a2c8ac8963ffdeba7523579d2ec98b22c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga58a8c0ce4aa40191214d1fa2c009adb3">ParsingError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c8ac8963ffdeba7523579d2ec98b22c">mError</a></td></tr>
<tr class="memdesc:a2c8ac8963ffdeba7523579d2ec98b22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a parsing error that occured.  <br /></td></tr>
<tr class="separator:a2c8ac8963ffdeba7523579d2ec98b22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="a2c8ac8963ffdeba7523579d2ec98b22c" name="a2c8ac8963ffdeba7523579d2ec98b22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8ac8963ffdeba7523579d2ec98b22c">&#9670;&#160;</a></span>mError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga58a8c0ce4aa40191214d1fa2c009adb3">ParsingError</a> ParsingResult::mError</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value indicates to the caller of <code>cap_parser_parse_noexit</code> what error message should be created, if any. It also indicates the meaning of <code>mFirstErrorWord</code> and <code>mSecondErrorWord</code>. <code>PER_NO_ERROR</code> indicates successful parsing. </p>

</div>
</div>
<a id="a48c6f8ff95fa3c73d1123fd6df91f6cf" name="a48c6f8ff95fa3c73d1123fd6df91f6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c6f8ff95fa3c73d1123fd6df91f6cf">&#9670;&#160;</a></span>mFirstErrorWord</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ParsingResult::mFirstErrorWord</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The nmeaning of this word depends on <code>mError</code>. </p>

</div>
</div>
<a id="ab60ebef2cf17c39ca0daaf50604ab93c" name="ab60ebef2cf17c39ca0daaf50604ab93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60ebef2cf17c39ca0daaf50604ab93c">&#9670;&#160;</a></span>mSecondErrorWord</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ParsingResult::mSecondErrorWord</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The nmeaning of this word depends on <code>mError</code>. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga58a8c0ce4aa40191214d1fa2c009adb3" name="ga58a8c0ce4aa40191214d1fa2c009adb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58a8c0ce4aa40191214d1fa2c009adb3">&#9670;&#160;</a></span>ParsingError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga58a8c0ce4aa40191214d1fa2c009adb3">ParsingError</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identifies a parse-time error for the purpose of noexit parsing. The function <code>cap_parser_parse</code> constructs an error message depending on the error type. Each error can supply up to two other words to be insreted into the message, such as the name of a flag. If an error type expects any additional words, it is written in a comment block above it. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3a6f001fa527c8eaf63b34577be447dad8" name="gga58a8c0ce4aa40191214d1fa2c009adb3a6f001fa527c8eaf63b34577be447dad8"></a>PER_NO_ERROR&#160;</td><td class="fielddoc"><p>No error. </p>
<p>This value is given when parsing was successful. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3a796384e69d34756fa38cca83fa8a7092" name="gga58a8c0ce4aa40191214d1fa2c009adb3a796384e69d34756fa38cca83fa8a7092"></a>PER_HELP&#160;</td><td class="fielddoc"><p>Help flag was encountered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3af9a637955ea2ab0009e71b0662e99efa" name="gga58a8c0ce4aa40191214d1fa2c009adb3af9a637955ea2ab0009e71b0662e99efa"></a>PER_NOT_ENOUGH_POSITIONALS&#160;</td><td class="fielddoc"><p>Some required positionals were omitted. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3a7ca650aa9cc7031a96b216993fa837d7" name="gga58a8c0ce4aa40191214d1fa2c009adb3a7ca650aa9cc7031a96b216993fa837d7"></a>PER_TOO_MANY_POSITIONALS&#160;</td><td class="fielddoc"><p>Too many positionals were given. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3a50abee75e07b8446b46f1d2010775408" name="gga58a8c0ce4aa40191214d1fa2c009adb3a50abee75e07b8446b46f1d2010775408"></a>PER_CANNOT_PARSE_POSITIONAL&#160;</td><td class="fielddoc"><p>Cannot parse a value given for a positional. </p>
<p>Cannot parse a value that was given for a positional argument, with respect to its type. Additional words are the name of the positional and the problematic value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3ae40c71ef696f53131aaf88b97d98a826" name="gga58a8c0ce4aa40191214d1fa2c009adb3ae40c71ef696f53131aaf88b97d98a826"></a>PER_UNKNOWN_FLAG&#160;</td><td class="fielddoc"><p>An unknown flag was encountered. </p>
<p>The parser found an unknown flag. Additional word is the name of the unknown flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3a00280011690dddf0a70a1c9a579f7ae8" name="gga58a8c0ce4aa40191214d1fa2c009adb3a00280011690dddf0a70a1c9a579f7ae8"></a>PER_MISSING_FLAG_VALUE&#160;</td><td class="fielddoc"><p>No value was given for a flag. </p>
<p>A flag with a type other than <code>DT_PRESENCE</code> is missing a value. Additional word is the name of the flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3a9a6349c74f2cc86c6fe1f123b017c81b" name="gga58a8c0ce4aa40191214d1fa2c009adb3a9a6349c74f2cc86c6fe1f123b017c81b"></a>PER_CANNOT_PARSE_FLAG&#160;</td><td class="fielddoc"><p>Cannot parse a value given to a flag. </p>
<p>Cannot parse a value that was given for a flag with respect to the flag's type. Additional words are the name of the flag and the problematic value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3ac4fb5d8eece8a5211e776eb564a773c2" name="gga58a8c0ce4aa40191214d1fa2c009adb3ac4fb5d8eece8a5211e776eb564a773c2"></a>PER_NOT_ENOUGH_FLAGS&#160;</td><td class="fielddoc"><p>A flag was not given enough times. </p>
<p>A flag was given less times than is required by the parser configuration. Additional word is the name of the flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga58a8c0ce4aa40191214d1fa2c009adb3a29753f054e3afe4c93abe4bfd6153835" name="gga58a8c0ce4aa40191214d1fa2c009adb3a29753f054e3afe4c93abe4bfd6153835"></a>PER_TOO_MANY_FLAGS&#160;</td><td class="fielddoc"><p>A flag was given too many times. </p>
<p>A flag was given more times than is required by the parser configuration. Additional word is the name of the flag. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga984d16e375dd8704a3682e0bcecddfae" name="ga984d16e375dd8704a3682e0bcecddfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984d16e375dd8704a3682e0bcecddfae">&#9670;&#160;</a></span>cap_parser_add_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_add_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>meta_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Behaves the same as cap_parser_add_flag_noexit but prints an error message and exits the program if an error is encountered.</p>
<p>Registers a new flag in <code>parser</code> under the name <code>flag</code>. The flag's name must be unique and the program exits with an error if a duplicate flag name is given. Flag names may not be identical to the flag separator. Do note that, the <code>cap_parser_make_default</code> factory returns a parser containg the default flag separator and the default help falg '-h'. Additionally, the flag name must begin with a flag prefix character, either the default '-' or one of the characters previously configured using <code>cap_parser_set_flag_prefix</code>.</p>
<p>The <code>type</code> parameter specifies the type of the value stored in this flag. The type <code>DT_PRESENCE</code> should be used if a flag should not store any explicit values (i.e. the flag's presence or absence is the only information associated with it). For all other types the next word on the command line is used as the flag's value. If it cannot be parsed at parse-time, the program exits with an error message.</p>
<p>The <code>min_count</code> and <code>max_count</code> parameters specify the minimum and maximum times the flag can be present on the command line. If a flag is found less than <code>min_count</code> times or more than <code>max_count</code> times, the program exits with an error at parse-time. This pair of parameters can be used to create required flags, flags that may be given up to once, and similar constructs. If <code>max_count</code> is negative, the flag can be read up to any number of times.</p>
<p>The <code>metavar</code> parameter specifies how the value of the flag should be displayed in usage and help messages. If <code>NULL</code> is given, the flag's data type is used instead. The <code>description</code> parameter provides a short explanation of the flag that will be displayd in help messages automatically generated by the parser. If <code>NULL</code> is given, no description is displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to create the flag in </td></tr>
    <tr><td class="paramname">flag</td><td>null-terminated name of the new flag, including flag prefix charactes (e.g. '-') </td></tr>
    <tr><td class="paramname">type</td><td>data type of the flag's values </td></tr>
    <tr><td class="paramname">min_count</td><td>minimum number of times the flag must be given on the command line. Must be at least zero. </td></tr>
    <tr><td class="paramname">max_count</td><td>maximum number of times the flag may be given on the command line. Must be either negative or at least <code>min_count</code>. </td></tr>
    <tr><td class="paramname">meta_var</td><td>display name of the flag's value in help messages </td></tr>
    <tr><td class="paramname">description</td><td>short description of the flag's meaning to display in automatically generated help messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d6eae74cf8edcdfa5897c7ead149ce7" name="ga0d6eae74cf8edcdfa5897c7ead149ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d6eae74cf8edcdfa5897c7ead149ce7">&#9670;&#160;</a></span>cap_parser_add_flag_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_add_flag_alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>alias</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new flag to the parser which functions as an alias for an existing flag. When parsing, this alias is parsed the same way as the original flag, and any value parsed for the alias is stored with the original flag's name (not under the alias.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">name</td><td>original flag name. Must be an existing flag. </td></tr>
    <tr><td class="paramname">alias</td><td>alias for 'name'. Must be a new, unique flag name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadf0403567eae7009db5175f7fd29455" name="gaadf0403567eae7009db5175f7fd29455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf0403567eae7009db5175f7fd29455">&#9670;&#160;</a></span>cap_parser_add_flag_alias_noexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddFlagAliasError cap_parser_add_flag_alias_noexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>alias</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Behaves the same as cap_parser_add_flag_alias but returns an error code instead of exiting when an error is encountered.</p>
<p>Adds a new flag to the parser which functions as an alias for an existing flag. When parsing, this alias is parsed the same way as the original flag, and any value parsed for the alias is stored with the original flag's name (not under the alias.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">name</td><td>original flag name. Must be an existing flag. </td></tr>
    <tr><td class="paramname">alias</td><td>alias for 'name'. Must be a new, unique flag name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2c06909958e3744b377ac6e484b16e0" name="gae2c06909958e3744b377ac6e484b16e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c06909958e3744b377ac6e484b16e0">&#9670;&#160;</a></span>cap_parser_add_flag_noexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddFlagError cap_parser_add_flag_noexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>metavar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Behaves the same as cap_parser_add_flag but returns an error code instead of exiting when an error is encountered.</p>
<p>Registers a new flag in <code>parser</code> under the name <code>flag</code>. The flag's name must be unique and must be different from the flag separator (if one is configured). Do note that, the <code>cap_parser_make_default</code> factory returns a parser containg the default flag separator and the default help falg '-h'. Additionally, the flag name must begin with a flag prefix character, either the default '-' or one of the characters previously configured using <code>cap_parser_set_flag_prefix</code>.</p>
<p>The <code>type</code> parameter specifies the type of the value stored in this flag. The type <code>DT_PRESENCE</code> should be used if a flag should not store any explicit values (i.e. the flag's presence or absence is the only information associated with it). For all other types the next word on the command line is used as the flag's value. If it cannot be parsed at parse-time, the program exits with an error message.</p>
<p>The <code>min_count</code> and <code>max_count</code> parameters specify the minimum and maximum times the flag can be present on the command line. If a flag is found less than <code>min_count</code> times or more than <code>max_count</code> times, the program exits with an error at parse-time. This pair of parameters can be used to create required flags, flags that may be given up to once, and similar constructs. If <code>max_count</code> is negative, the flag can be read up to any number of times.</p>
<p>The <code>metavar</code> parameter specifies how the value of the flag should be displayed in usage and help messages. If <code>NULL</code> is given, the flag's data type is used instead. The <code>description</code> parameter provides a short explanation of the flag that will be displayd in help messages automatically generated by the parser. If <code>NULL</code> is given, no description is displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to create the flag in </td></tr>
    <tr><td class="paramname">flag</td><td>null-terminated name of the new flag, including flag prefix charactes (e.g. '-') </td></tr>
    <tr><td class="paramname">type</td><td>data type of the flag's values </td></tr>
    <tr><td class="paramname">min_count</td><td>minimum number of times the flag must be given on the command line. Must be at least zero. </td></tr>
    <tr><td class="paramname">max_count</td><td>maximum number of times the flag may be given on the command line. Must be either negative or at least <code>min_count</code>. </td></tr>
    <tr><td class="paramname">metavar</td><td>display name of the flag's value in help messages </td></tr>
    <tr><td class="paramname">description</td><td>short description of the flag's meaning to display in automatically generated help messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code representing the kind of error that occurs, or AFE_OK if a flag was added successfully </dd></dl>

</div>
</div>
<a id="gae510ae93fe4d5048f8566a2801abd156" name="gae510ae93fe4d5048f8566a2801abd156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae510ae93fe4d5048f8566a2801abd156">&#9670;&#160;</a></span>cap_parser_add_positional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_add_positional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>required</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>variadic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>metavar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures a new positional argument in <code>parser</code> with the name <code>name</code>. If a positional argument with the same name already exists, the program exits with an error.</p>
<p>The data type of the argument's value is given by the <code>type</code> parameter. If the type <code>DT_PRESENCE</code> is used, the program exits with an error. The positional argument's type is used to parse a value at parse-time. If the word given on the command line cannot be parsed as that type, parsing terminates with an error.</p>
<p>If <code>required</code> is false, this argument will be configured as optional. Required positionals may not be configured after any number of optional ones. At parse-time, optional positionals may be missing on the command line.</p>
<p>If <code>variadic</code> is true, this argument can take multiple values. After one variadic argument, no other arguments may be configured. Note that, a variadic argument can also be required. At parse-time, all available command line words that are not flags are used as values for the variadic argument. If it is also required, at least one such word must be found.</p>
<p>The <code>metavar</code> parameter specifies the display name of this argument in help and usage messages. If <code>NULL</code> is given, the argument's <code>name</code> is used instead. The <code>description</code> parameter specifies a short explanation of the argument that will be displayed in help messages automatically generated by the parser. If <code>NULL</code> is given, no description is displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">name</td><td>name of the new argument </td></tr>
    <tr><td class="paramname">type</td><td>data type of the new argument </td></tr>
    <tr><td class="paramname">required</td><td>if the argument is required </td></tr>
    <tr><td class="paramname">variadic</td><td>variadicity of the argument, see above for the constraints </td></tr>
    <tr><td class="paramname">metavar</td><td>display name for this argument in help messages </td></tr>
    <tr><td class="paramname">description</td><td>short description of the argument's meaning to display in automatically generated help messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9c1516b2e3b6bf3a8d2ce1d4257097e" name="gae9c1516b2e3b6bf3a8d2ce1d4257097e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c1516b2e3b6bf3a8d2ce1d4257097e">&#9670;&#160;</a></span>cap_parser_add_positional_noexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddPositionalError cap_parser_add_positional_noexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/dba/group__typed__union.html#gad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>required</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>variadic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>metavar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures a new positional argument in <code>parser</code> with the name <code>name</code>. If a positional argument with the same name already exists, returns an appropriate error code.</p>
<p>The data type of the argument's value is given by the <code>type</code> parameter. If the type <code>DT_PRESENCE</code> is used, an error code is returned. The positional argument's type is used to parse a value at parse-time. If the word given on the command line cannot be parsed as that type, parsing terminates with an error.</p>
<p>If <code>required</code> is false, this argument will be configured as optional. Required positionals may not be configured after any number of optional ones. At parse-time, optional positionals may be missing on the command line.</p>
<p>If <code>variadic</code> is true, this argument can take multiple values. After one variadic argument, no other arguments may be configured. Note that, a variadic argument can also be required. At parse-time, all available command line words that are not flags are used as values for the variadic argument. If it is also required, at least one such word must be found.</p>
<p>The <code>metavar</code> parameter specifies the display name of this argument in help and usage messages. If <code>NULL</code> is given, the argument's <code>name</code> is used instead. The <code>description</code> parameter specifies a short explanation of the argument that will be displayed in help messages automatically generated by the parser. If <code>NULL</code> is given, no description is displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">name</td><td>name of the new argument </td></tr>
    <tr><td class="paramname">type</td><td>data type of the new argument </td></tr>
    <tr><td class="paramname">required</td><td>required-ness of the argument, see above for constraints </td></tr>
    <tr><td class="paramname">variadic</td><td>variadicity of the argument, see above for the constraints </td></tr>
    <tr><td class="paramname">metavar</td><td>display name for this argument in help messages </td></tr>
    <tr><td class="paramname">description</td><td>short description of the argument's meaning to display in automatically generated help messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO </dd></dl>

</div>
</div>
<a id="gaed98696f672b0b407dae5719221fc748" name="gaed98696f672b0b407dae5719221fc748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed98696f672b0b407dae5719221fc748">&#9670;&#160;</a></span>cap_parser_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys an <code><a class="el" href="#d5/db0/structArgumentParser" title="Main object for parsing given command line arguments.">ArgumentParser</a></code> object and all data stored in it. <code>ParsedArgument</code> objects created using this parser are not owned by it and can be used after a parser is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to destroy. If it is <code>NULL</code>, nothing happens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6dcbda38abac6c517adffa18fe2bef9" name="gae6dcbda38abac6c517adffa18fe2bef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6dcbda38abac6c517adffa18fe2bef9">&#9670;&#160;</a></span>cap_parser_enable_help()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_enable_help </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temporarily enables or disables displaying help messages. When disabling help by setting <code>enable</code> to <code>false</code>, information such as program description is not removed. Note that, changing any help configuration when displaying help is disabled does not re-enable it. Help must be manually re-enabled using this function. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">enable</td><td><code>true</code> if help should be displayed, <code>false</code> if not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec3ea97a7a66869e1e7e2191323e2633" name="gaec3ea97a7a66869e1e7e2191323e2633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec3ea97a7a66869e1e7e2191323e2633">&#9670;&#160;</a></span>cap_parser_enable_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_enable_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temporarily enables or disables displaying usage messages. When disabling usage by setting <code>enable</code> to <code>false</code>, information such as custom usage is not removed. Note that, changing any related configuration when displaying usage is disabled does not re-enable it. Usage must be manually re-enabled using this function. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">enable</td><td><code>true</code> if usage should be displayed, <code>false</code> if not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46213ece4e095432953aadf16f396ea1" name="ga46213ece4e095432953aadf16f396ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46213ece4e095432953aadf16f396ea1">&#9670;&#160;</a></span>cap_parser_get_program_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * cap_parser_get_program_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argv0</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the custom program name configured in <code>parser</code> or guesses the executable's name from <code>argv0</code> if not name has been configured. If <code>parser</code> has no program name, the part of &lsquo;argv0&rsquo; after the right-most path separator is used. On Windows, both '\' and '/' are considered path separators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser object to consult </td></tr>
    <tr><td class="paramname">argv0</td><td>first word on the command line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>configured or estimated program name </dd></dl>

</div>
</div>
<a id="gabc09eb179b1199958b0aed13020ec884" name="gabc09eb179b1199958b0aed13020ec884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc09eb179b1199958b0aed13020ec884">&#9670;&#160;</a></span>cap_parser_make_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> * cap_parser_make_default </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new parser with default configuration. It differs from an empty parser in that it contains the automatic help flag "-h" and the flag separator "--" that switches the parser to positional-only mode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga13174dda05075576f8e1fffb4356bb49" title="Creates a new empty parser.">cap_parser_make_empty</a> </dd>
<dd>
<a class="el" href="#gaed98696f672b0b407dae5719221fc748" title="Destroys an ArgumentParser object.">cap_parser_destroy</a> </dd></dl>

</div>
</div>
<a id="ga13174dda05075576f8e1fffb4356bb49" name="ga13174dda05075576f8e1fffb4356bb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13174dda05075576f8e1fffb4356bb49">&#9670;&#160;</a></span>cap_parser_make_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> * cap_parser_make_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new parser with no configured flags or positional arguments. The caller becomes the owner of this new object and should dispose of it using <code>cap_parser_destroy</code> when it is no longer needed.</p>
<dl class="section return"><dt>Returns</dt><dd>new object</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaed98696f672b0b407dae5719221fc748" title="Destroys an ArgumentParser object.">cap_parser_destroy</a> </dd>
<dd>
<a class="el" href="#gabc09eb179b1199958b0aed13020ec884" title="Creates a new default parser.">cap_parser_make_default</a> </dd></dl>

</div>
</div>
<a id="ga67e5587843006db2bd43c2f2ad6c08b3" name="ga67e5587843006db2bd43c2f2ad6c08b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e5587843006db2bd43c2f2ad6c08b3">&#9670;&#160;</a></span>cap_parser_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments">ParsedArguments</a> * cap_parser_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses command line words using a given parser. If a parsing error occurs, the program exits with an error message.</p>
<p>On successful parsing returns a pointer to a <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object containing all parsed flags and positional arguments. The caller is the owner of this object - it can be used even after the parser is destroyed using <code>cap_parser_destroy</code> and needs to be destroyed using <code>cap_pa_destroy</code> and a subsequent call to <code>free</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser object to use </td></tr>
    <tr><td class="paramname">argc</td><td>number of command line words </td></tr>
    <tr><td class="paramname">argv</td><td>array of command line words </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a new <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> object containing information on parsed flags and positional arguments. </dd></dl>

</div>
</div>
<a id="gacdd6d249ea681d433a52ca47298383ec" name="gacdd6d249ea681d433a52ca47298383ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdd6d249ea681d433a52ca47298383ec">&#9670;&#160;</a></span>cap_parser_parse_noexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#db/d05/structParsingResult">ParsingResult</a> cap_parser_parse_noexit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses given command line words using the given parser. When a parsing error occurs, parsing terminates and an appropriate result is returned. This function should not be called directly by the user, <code>cap_parser_parse</code> should be used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser object to use </td></tr>
    <tr><td class="paramname">argc</td><td>number of command line arguments </td></tr>
    <tr><td class="paramname">argv</td><td>array of command line arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the parsing, containing a <code><a class="el" href="../../d0/d0d/group__parsed__arguments.html#d2/d4a/structParsedArguments" title="Stores all information about command line arguments after successful parsing.">ParsedArguments</a></code> if parsing was successful. </dd></dl>

</div>
</div>
<a id="ga2b39c8bb05b3084f5e373a6e2c7d4b3e" name="ga2b39c8bb05b3084f5e373a6e2c7d4b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b39c8bb05b3084f5e373a6e2c7d4b3e">&#9670;&#160;</a></span>cap_parser_print_help()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_print_help </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a help message to <code>file</code>. This message is either set explicitly using <code>cap_parser_set_custom_help</code>, or generated based on flag/argument configuration of <code>parser</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser to generate or extract the help message from </td></tr>
    <tr><td class="paramname">file</td><td>write the message here</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga50c078c2e4cf4b884e5c60b1b0541383" title="Sets a custom help message.">cap_parser_set_custom_help</a> </dd>
<dd>
<a class="el" href="#gaf05828f893b3919311e60582aff8fd10" title="Sets the program&#39;s description.">cap_parser_set_description</a> </dd>
<dd>
<a class="el" href="#ga0241869c382f2c422f57649e45119ed3" title="Sets the epilogue of the program&#39;s help.">cap_parser_set_epilogue</a> </dd>
<dd>
<a class="el" href="#ga984d16e375dd8704a3682e0bcecddfae" title="Registers a flag in an argument parser.">cap_parser_add_flag</a> </dd>
<dd>
<a class="el" href="#gae510ae93fe4d5048f8566a2801abd156" title="Configures a new positional argument.">cap_parser_add_positional</a> </dd></dl>

</div>
</div>
<a id="ga9947372999a822fffdb60534d2676382" name="ga9947372999a822fffdb60534d2676382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9947372999a822fffdb60534d2676382">&#9670;&#160;</a></span>cap_parser_print_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_print_usage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argv0</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a usage string to <code>file</code> based on the flags and arguments configured in <code>parser</code>. If a flag has aliases, the shortest available name is picked. </p>

</div>
</div>
<a id="ga50c078c2e4cf4b884e5c60b1b0541383" name="ga50c078c2e4cf4b884e5c60b1b0541383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50c078c2e4cf4b884e5c60b1b0541383">&#9670;&#160;</a></span>cap_parser_set_custom_help()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_custom_help </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>help</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a custom help message to displays instead of an automatically generated one. The given text is displayed verbatim whenever a help message is printed. This configuration overrides the configuration done using <code>cap_parser_set_description</code>, <code>cap_parser_set_epilogue</code> and setting metavars for flags and arguments for the purposes of displaying a help message. Those configurations are not removed by calling this function, however.</p>
<p>Unlike <code>cap_parser_set_description</code>, <code>cap_parser_set_epilogue</code>, or <code>cap_parser_set_program_name</code>, if <code>help</code> is <code>NULL</code>, the parser is configured to automatically generate help messages. An empty help can be configured by passing an empty string to this function.</p>
<p>If <code>help</code> is not <code>NULL</code>, a copy of it is created and <code>parser</code> becomes the owner of that copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">help</td><td>custom help message, or <code>NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8d359e80759d76dcdb8546ea1e27341" name="gab8d359e80759d76dcdb8546ea1e27341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8d359e80759d76dcdb8546ea1e27341">&#9670;&#160;</a></span>cap_parser_set_custom_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_custom_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>usage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a custom usage message to display instead of an automatically generated one. The given text is displayed verbatim whenever a help message is to be printed. If <code>usage</code> is <code>NULL</code>, the parser reverts to generating usage automatically.</p>
<p>An empty string should be used if usage should be blank. Alternately, usage can be suppressed by calling <code>cap_parser_enable_usage</code>. If usage was previously disabled using <code>cap_parser_enable_usage(false)</code>, it does not get re-enabled by calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">usage</td><td>null-terminated verbatim usgage string, or <code>NULL</code> to revert to automatic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf05828f893b3919311e60582aff8fd10" name="gaf05828f893b3919311e60582aff8fd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05828f893b3919311e60582aff8fd10">&#9670;&#160;</a></span>cap_parser_set_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the description of the program that is displayed at the beginning of the automatically generated help message. By default no description is printed. A previously configured description can be removed using this function by giving <code>NULL</code> as the second parameter.</p>
<p>If <code>description</code> is not <code>NULL</code>, a copy of it is created and <code>parser</code> becomes the owner of that copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser object to configure </td></tr>
    <tr><td class="paramname">description</td><td>null-terminated description of the program, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0241869c382f2c422f57649e45119ed3" name="ga0241869c382f2c422f57649e45119ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0241869c382f2c422f57649e45119ed3">&#9670;&#160;</a></span>cap_parser_set_epilogue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>epilogue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an epilogue of the program's description which is displayed at the end of the automatically generated help message. By default no epilogue is printed and a previously configured epilogue can be removed by giving <code>NULL</code> as the second parameter.</p>
<p>If <code>epilogue</code> is not <code>NULL</code>, a copy of it is created and <code>parser</code> becomes the owner of that copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">epilogue</td><td>epilogue of the help message, or <code>NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9d15cfb79e9c90649edf0d09d52c1d1" name="gad9d15cfb79e9c90649edf0d09d52c1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9d15cfb79e9c90649edf0d09d52c1d1">&#9670;&#160;</a></span>cap_parser_set_flag_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_flag_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix_chars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures a set of characters to be considered flag-prefixes by the parser. Any command line word that begins with one of these characters is considered a flag unless parsing in positional-only mode, see below. By default, '-' (dash) is considered the only prefix character.</p>
<p>If <code>parser</code> is <code>NULL</code>, nothing happens. If <code>prefix_chars</code> is <code>NULL</code> or empty, the program exits with an error.</p>
<p>Note that, this configuration must be done before adding any flags, because added flags are required to begin with a flag prefix character. If any flags are present when calling this function, the program exits with an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser object to configure </td></tr>
    <tr><td class="paramname">prefix_chars</td><td>null-terminated string of characters that should be considered flag prefixes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30894b0158cf392fc1489b22e52b1223" name="ga30894b0158cf392fc1489b22e52b1223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30894b0158cf392fc1489b22e52b1223">&#9670;&#160;</a></span>cap_parser_set_flag_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_flag_separator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures a parser to recognize a flag separator, or to not have one. A flag separator is a special flag that, when found on the command line, puts the parser in positional only mode. In this mode all command line words are used as positionals even if they begin with a flag prefix character. By default the flag separator is '&ndash;' (double dash).</p>
<p>If the given string is empty or a flag already exists with the same name, the program exits with an error. This string is copied into the parser and the caller remains the owner of the given pointer.</p>
<p>The <code>description</code> parameter allows to set a short description of this separator which appears in help messages. If <code>NULL</code> is given, a default description is used. If the description should be blank, an empty string should be passed to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser object to configure </td></tr>
    <tr><td class="paramname">separator</td><td>null-terminated string containing the new flag separator. If <code>NULL</code> is given, the flag separator is explicitly disabled. </td></tr>
    <tr><td class="paramname">description</td><td>short description of this symbol for use in help mesages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef82bc92775d7902066744534c7f3f86" name="gaef82bc92775d7902066744534c7f3f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef82bc92775d7902066744534c7f3f86">&#9670;&#160;</a></span>cap_parser_set_help_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_help_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a flag that makes the program immediately display help information and exit. By default, this flag is "-h", but can be overriden using this function.</p>
<p>If <code>name</code> is <code>NULL</code> and a help flag is already configured, it is removed. If a duplicate or otherwise invalid <code>name</code> is given, the program exits with an error.</p>
<p>If <code>description</code> is <code>NULL</code>, a default is used. If the help flag should have no description, an empty string should be used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>object to configure </td></tr>
    <tr><td class="paramname">name</td><td>name of the custom help flag </td></tr>
    <tr><td class="paramname">description</td><td>description of the help flag. If it is <code>NULL</code>, a default is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08651dbf827fd7867224a35dd2a4b363" name="ga08651dbf827fd7867224a35dd2a4b363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08651dbf827fd7867224a35dd2a4b363">&#9670;&#160;</a></span>cap_parser_set_program_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cap_parser_set_program_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#d5/db0/structArgumentParser">ArgumentParser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the display name of the program for use in help and usage messages. By default, the program name is constructed from the first command line argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>parser object to configure </td></tr>
    <tr><td class="paramname">name</td><td>null-terminated name of the program. If NULL, the parser is reset to default behaviour (described above). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
